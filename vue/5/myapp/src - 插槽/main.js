import Vue from 'vue'
import App from './App.vue'

new Vue({
  el: '#app',
  render: h => h(App)
})


/*
  keep-alive  内置组件
    如果组件需要进行缓存的时候只要在需要缓存的组件标签外部加上一个内置组件keep-alive 那么这个组件就可以进入
    缓存状态

    keep-alive会使组件增加2个生命周期函数  一个是activated(活跃状态)  deactivated(缓存状态)

    keep-alive会有3个属性
      include  包含哪些组件进入缓存   
      exclude  排除哪些组件进入缓存
            值的类型:字符串 也可以是正则

      如果是正则表达式的时候需要将属性进行绑定

      max:最多可以缓存多少个组件


    slot插槽  slot是一个内置组件

      1、最基本使用
      
      当组件当做标签使用的时候,如果在组件标签内部嵌套一些标签的时候，这些元素是无法进行显示的
      如果需要进行显示的话  需要在组件内部通过slot进行接收 slot会将所以标签在同一个位置全部进行接收显示

      2、命名插槽
      好处：可以增加插槽的灵活性
        在组件标签内部属性书写标签的时候 给标签添加一个slot属性 值为插槽的名称  
        在组件内部通过slot进行接收  接收的同时将name属性添加到slot插槽中去  name的值为插槽的名称

      3、作用域插槽：带参数的插槽
        当组件当做标签使用的时候 如果需要将插槽中的数据使用组件内部的数据的时候 需要在组件标签内部加一个
        template标签   属性为scope  值任意值  用来接收当前组件传递过来的数据  
        使用的时候通过 属性值(props).属性(这个属性来自于组件内部绑定的属性)(val)

      <List-com>
        <template scope="props">
          <div>{{props.val}}</div>
        </template>
      
      </List-com>
       组件内部
       <slot :val="message"></slot>


       封装Vue组件的过程？
        1、组件的复用性
        2、组件需要暴露的API
        // 在子组件中写出模板，在父组件中写出数据，通过自定义属性将属性（组件需要暴露的API）传到子组件中，在此使用的时候
        // 引入子组件即可，将其子组件的父组件引入数据即可，实现组件的复用
        a、组件传值
            父传子
            子传父
            非父子
          slot插槽
          props接收


*/